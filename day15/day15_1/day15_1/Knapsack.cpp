//Knapsack Problem
/*
배낭의 최대 용량(무게)과 item의 무게 및 가치를 고려하여 배낭을 채우는 문제

wi = item_i의 무게
pi = item_i의 가치

W = 배낭에 넣을 수 있는 총 무게

wi의 합 <= W를 만족하면서 pi의 합이 최대가 되도록 하는 문제이다.

<해결 방법>
1. 브루트 포스 알고리즘
	- n개의 물건에 대해서 모든 부분집합을 전부 고려
	- 크기가 n인 집합의 부분집합의 수는 2^n이므로 시간복잡도가 너무 크다는 단점이 있음

2. greedy(탐욕적) 알고리즘
	(1) 가장 비싼 item부터 우선적으로 채운다.
	- 최적의 알고리즘은 아니다.
	(2) 무게 당 가치가 높은 물건부터 우선적으로 채운다.
	- 역시 최적의 알고리즘이 아니다.
	- 그러나 item을 잘라서 담을 수 있다면 이 방법이 최적이 된다.

3. 동적계획적인 접근 방법
	- P[i][w]: i > 0이고 w > 0일 때, 무게가 w가 넘지 않도록 i번째까지의 항목중에서 얻어진 최고의 이익

	  P[i][w] = { max(P[i-1][w], pi + P[i-1][w-wi]) if. wi <= w
				{ P[i-1][w]							if. wi > w
	
	- wi를 담을 수 있는 상황이라면 wi를 안담는 경우와 i-1까지 담고 wi를담은 상태에서의 가치를 비교하고,
	  wi를 담을 수 없는 상황(안 담는 경우)이라면 i-1까지만 담는다는 것을 식으로 표현한 것이다.

	  (즉, P[i-1][w]는 i번째 항목을 포함시키지 않는 경우의 최고 이익이고
	       pi + P[i-1][w-wi]는 i번째 항목을 포함시키는 경우의 최고 이익이다.)

	- 여기서 n과 W는 아무런 상관관계가 없으며, W = n!이라고 가정하면 수행시간은 O(n*n!)이 되므로 브루프 포스 알고리즘보다도 못하게 된다.

	- 이 알고리즘이 브루프 포스 알고리즘보다 느리지 않으면서도 때로는 훨씬 빠르게 수행될 수 있도록 개량해야한다.
	  착안점은 P[n][W]를 계산하기 위해 (n-1)번째 행을 모두 계산할 필요가 없다는 것에 있다.
	  ( P[n-1][W]와 P[n-1][W-w0] 두 항만 계산 )

	=> 계산량은 O(minimum(2^n, nW))이다.

	아무도 이 문제의 최악의 경우 수행시간이 지수보다 나은 알고리즘을 발견하지 못했고, 그러한 알고리즘은 없다라고도 증명되지 않았다. => NP문제
*/

#include <iostream>
using namespace std;

// 무게와 가치로 이루어진 구조체 item
struct Item {
	int weight, val;
};

// 견딜 수 있는 무게 k에 따른 i번째 item까지의 총 가치합을 나타낼 배열 P
// n은 item의 개수, k는 가방이 견딜 수 있는 무게
int P[100][100], n, k;

// item 구조체 변수 gem을 생성하여 최대 개수 설정
Item gem[100];

int main() {
	cout << "보석의 수: ";
	cin >> n;
	cout << "가방의 최대 용량: ";
	cin >> k;

	// 보석의 무게와 가치를 입력받음
	for (int i = 1; i <= n; i++) {
		int w, v;
		cout << "보석: " << i << endl;
		cout << "보석의 무게: ";
		cin >> w;
		cout << "보석의 가치: ";
		cin >> v;
		gem[i] = { w,v };
	}

	// 최적해 계산
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= k; j++) {
			int wi = gem[i].weight;
			int vi = gem[i].val;

			// 못담는 경우
			if (wi > j) {
				P[i][j] = P[i - 1][j];
			}
			// 담을 수 있는 경우
			else {
				P[i][j] = max(P[i - 1][j], vi + P[i - 1][j - wi]);
			}
		}
	}
	
	cout << "최대 가치의 합: " << P[n][k] << endl;
}