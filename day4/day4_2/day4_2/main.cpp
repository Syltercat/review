// operator overloading 기초

/*
연산자 오버로딩: 기본형 연산자를 사용자 정의형 연산자로 사용 가능하게 함
(단, 새로운 연산자를 만들 수 는 없다. 기존 연산자를 사용자 정의 타입에 사용할 수 있도록 하는 것이다.)

<연산자 오버로딩으로 변경 불가능 한 것과 주의사항>
1. 연산자의 우선순위를 바꿀 수는 없다.
2. 연산자의 결합 순서를 바꿀 수는 없다.
3. 피연산자의 개수를 바꿀 수는 없다.
4. 내장 타입(ex. int의 + 연산자 의미...)의 객체에 적용되는 연산 방법을 바꿀 수는 없다.
5. 새로운 연산자를 만드는 것은 불가능하다.
6. 연산자는 명확하게 오버로딩 되어야 한다. (=과 +가 오버로딩 되었다고 해서 += 연산자가 오버로딩 된 것은 아니다.)

<멤버 함수로서의 연산자 함수>
피연산자1 연산자 피연산자2 의 구성일 경우 연산자가 정의된 클래스의 객체는 피연산자1이 되어야 한다.
	-> P1 + P2 == P1.add(P2)이기 때문
	-> 이항 연산자의 왼쪽 피연산자의 인자를 얻기 위해 암시적으로 this 키워드를 사용한다.

<전역 함수로서의 연산자 함수>
	- 함수 매개변수들을 필요로한다.
	- 연산자와 다른 클래스의 객체를 매개 변수로 취할 수 있다.

	- <<, >> 연산자 오버로딩
		*ostream &형의 왼쪽 피연산자 (cout << x 에서의 cout)를 취한다.
		*istream &형의 왼쪽 피연산자 (cin >> x 에서의 cin)를 취한다.
		=> 따라서 전역 함수로 구현해야한다.

<교환 법칙이 성립하는 전역 함수로서의 연산자>
	* classname + int 와 같이 class 객체가 왼쪽에 나타날 경우 멤버 함수로 구현 가능하다.
	* int + classname 과 같을 경우에는 전역 오버로딩 함수가 필요하다.
	* => 따라서 교환법칙이 성립하도록 하려면 전역 함수로 연산자를 오버로딩 해야한다.

<멤버 함수 / 전역 함수 구분 방법>
왼쪽 연산자가 사용자 변경 가능하면(= 사용자가 만든 것이라면) 멤버 함수로 구현
왼쪽 연산자가 기존에 만들어져(= 시스템 제공) 변경이 불가능하다면 전역 함수로 구현
	=> cin, cout의 경우 변경 불가하기 때문에 전역 함수로 구현
*/

#include <iostream>
#include "PhoneNumber.h"

using namespace std;

int main() {
	PhoneNumber phone;
	cout << "enter phone num. entered form is (xxx)xxx-xxxx: ";
	cin >> phone;
	cout << "entered phone num: " << phone << endl;
	return 0;
}